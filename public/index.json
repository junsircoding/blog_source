[{"categories":null,"content":" 文章封面, 由作者通过 Canva 网站制作 到目前为止，我接触到的气象相关数据有站点数据、等经纬度网格数据和 WRF（天气研究与预报）数据。 注：为叙述简便，等经纬度网格数据 下简称 网格数据，WRF（天气研究与预报）数据 简称 WRF 数据，站点数据 不变。 WRF 数据暂未找到公开数据，先不做说明。下表列明了下文代码示例中用到的数据下载来源。 数据名称 下载来源 网格数据 https://cds.climate.copernicus.eu/#!/search?text=ERA5\u0026type=dataset，搜索station 站点数据 https://cds.climate.copernicus.eu/#!/search?text=ERA5\u0026type=dataset WRF 数据 暂无 站点数据通常用 Pandas 读取： import pandas as pd df = pd.read_csv(\"test_station.csv\", sep=\",\", encoding=\"utf-8\", comment=\"#\") print(df.columns) df = df[[\"latitude\", \"longitude\", \"total_column_water_vapour\"]] df.columns = [\"lat\", \"lon\", \"value\"] print(df) 结构就像这样： Index(['report_id', 'station_name', 'city', 'organisation_name', 'latitude', 'longitude', 'sensor_altitude', 'height_of_station_above_sea_level', 'start_date', 'report_timestamp', 'total_column_water_vapour'], dtype='object') lat lon value 0 49.186825 -68.263330 12.88 1 51.192345 14.521734 30.69 2 47.907738 7.632879 29.42 3 48.380493 -4.496594 15.99 4 50.798060 4.358563 19.01 ... ... ... ... 9811 60.750510 -135.222100 14.09 9812 52.236870 -122.167810 19.11 9813 34.226120 -118.055916 13.35 9814 62.481323 -114.480840 15.52 9815 62.480892 -114.480705 15.57 [9816 rows x 3 columns] 其中 lat 表示纬度，lon 表示经度，val 表示站点观测值。 这个数据用 VSCode 简单预览是这样： 网格数据通常用 Xarray 读取： import xarray as xr with xr.open_dataset(\"test_grid.nc\") as ds_nc: ds_nc = ds_nc.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_nc = ds_nc.isel(time=0)[\"t\"] # 用索引的方式选取首个 time 维度, 选取变量 t print(dr_nc) 结构就像这样： \u003cxarray.DataArray 't' (lat: 721, lon: 1440)\u003e [1038240 values with dtype=float32] Coordinates: * lon (lon) float32 0.0 0.25 0.5 0.75 1.0 ... 359.0 359.2 359.5 359.8 * lat (lat) float32 90.0 89.75 89.5 89.25 ... -89.25 -89.5 -89.75 -90.0 time datetime64[ns] 2020-07-01 Attributes: units: K long_name: Temperature standard_name: air_temperature 其中，lat 和 lon 是这个数据的两个维度，即纬度和经度，Coordinates 展示了这两个维度对应的坐标信息。 这个数据用 Panoply 简单预览是这样： 在实际使用过程中，经常会有这样的需求： 将网格数据插值到另一个坐标、分辨率不同的网格数据上 将网格数据插值到站点数据上 将站点数据插值到网格数据上 … ","date":"2023-05-29","objectID":"/20230529/:0:0","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将网格数据插值到另一个坐标、分辨率不同的网格数据上 我们这里再读取一个与 test_grid.nc 坐标不同的一个 grib2 格式的网格数据： import xarray as xr with xr.open_dataset( \"test_grid.grib2\", engine=\"cfgrib\", backend_kwargs={ \"indexpath\":\"\", 'filter_by_keys':{ 'typeOfLevel':'surface', 'shortName':'t', 'level':0 } } ) as ds_grib2: ds_grib2 = ds_grib2.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_grib2 = ds_grib2[\"t\"] print(dr_grib2) 结构就像这样： \u003cxarray.DataArray 't' (lat: 181, lon: 360)\u003e [65160 values with dtype=float32] Coordinates: time datetime64[ns] ... step timedelta64[ns] ... surface float64 ... * lat (lat) float64 90.0 89.0 88.0 87.0 ... -87.0 -88.0 -89.0 -90.0 * lon (lon) float64 0.0 1.0 2.0 3.0 4.0 ... 356.0 357.0 358.0 359.0 valid_time datetime64[ns] ... Attributes: (12/29) GRIB_paramId: 130 GRIB_dataType: fc GRIB_numberOfPoints: 65160 GRIB_typeOfLevel: surface GRIB_stepUnits: 1 GRIB_stepType: instant ... ... GRIB_name: Temperature GRIB_shortName: t GRIB_units: K long_name: Temperature units: K standard_name: air_temperature 用 Panoply 预览是这样： 可以看到 test_grid.nc 的经纬度坐标为 (lon: 1440, lat: 721)，test_grid.grib2 的经纬度坐标为 (lat: 181, lon: 360)，是不一样的。 如果我们想得到 nc 在 grib2 的坐标上对应的值，只要将 nc 插值到 grib2 上就可以了，代码如下： import xarray as xr with xr.open_dataset(\"test_grid.nc\") as ds_nc: ds_nc = ds_nc.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_nc = ds_nc.isel(time=0)[\"t\"] # 用索引的方式选取首个 time 维度, 选取变量 t with xr.open_dataset( \"test_grid.grib2\", engine=\"cfgrib\", backend_kwargs={ \"indexpath\":\"\", 'filter_by_keys':{ 'typeOfLevel':'surface', 'shortName':'t', 'level':0 } } ) as ds_grib2: ds_grib2 = ds_grib2.rename({\"latitude\":\"lat\", \"longitude\":\"lon\"}) # 重命名维度名称 dr_grib2 = ds_grib2[\"t\"] dr_nc_interp = dr_nc.interp(lat=dr_grib2.lat, lon=dr_grib2.lon) # 将 nc 插值到 grib2 的坐标上 print(dr_nc_interp) dr_nc_interp.to_netcdf(\"test_grid_interp.nc\") # 将插值后的数据导出成 nc 插值后的数据预览如下： \u003cxarray.DataArray 't' (lat: 181, lon: 360)\u003e array([[254.54649353, 254.54649353, 254.54649353, ..., 254.54649353, 254.54649353, 254.54649353], [252.3180542 , 252.36672974, 252.41772461, ..., 252.17819214, 252.2230072 , 252.2701416 ], [249.42973328, 249.46296692, 249.50082397, ..., 249.34706116, 249.3717804 , 249.39805603], ..., [234.89929199, 234.8343811 , 234.77180481, ..., 235.0947876 , 235.02911377, 234.96342468], [235.33354187, 235.33818054, 235.34359741, ..., 235.31808472, 235.32427979, 235.3289032 ], [235.04379272, 235.04379272, 235.04379272, ..., 235.04379272, 235.04379272, 235.04379272]]) Coordinates: time datetime64[ns] 2020-07-01 * lat (lat) float64 90.0 89.0 88.0 87.0 ... -87.0 -88.0 -89.0 -90.0 * lon (lon) float64 0.0 1.0 2.0 3.0 4.0 ... 356.0 357.0 358.0 359.0 step timedelta64[ns] 00:00:00 surface float64 0.0 valid_time datetime64[ns] 2016-10-06 Attributes: units: K long_name: Temperature standard_name: air_temperature 用 Panoply 查看插值后的数据，可以看到数据分布和 nc 是一样的，但是这两个数据的坐标是不一样的。 ","date":"2023-05-29","objectID":"/20230529/:0:1","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将网格数据插值到站点数据上 ","date":"2023-05-29","objectID":"/20230529/:0:2","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将 WRF 数据插值到站点数据上 ","date":"2023-05-29","objectID":"/20230529/:0:3","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"将站点数据插值到网格数据上（反距离权重插值） ","date":"2023-05-29","objectID":"/20230529/:0:4","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":"示例数据下载： nc grib2 station ","date":"2023-05-29","objectID":"/20230529/:0:5","tags":null,"title":"气象数据的各种插值问题","uri":"/20230529/"},{"categories":null,"content":" 文章封面, 由作者通过 Canva 网站制作 ","date":"2023-05-26","objectID":"/20230527/:0:0","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"用 Matplotlib 绘制 pcolormesh 填色图 Matplotlib 的 pcolormesh 可以将二维数据绘制成填色图，可以一目了然地展示数据的分布情况。官方文档的 Demo 展示了这个函数的简单使用方式。 import matplotlib.pyplot as plt import numpy as np np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = plt.figure(figsize=(16, 9)) # 创建画布 ax = fig.add_subplot(111) img = ax.pcolormesh(x, y, Z, cmap=\"jet\") # 添加填色实例, 设置色标 ax.set_xticks(x) # 设置 x 轴坐标 ax.set_yticks(y) # 设置 y 轴坐标 fig.colorbar(img, ax=ax) # 添加色带 fig.savefig(\"00_test.png\", bbox_inches='tight') # 执行绘图并导出成图片 生成的 Z 数据如下，形状为 6 行 10 列： 0 1 2 3 4 5 6 7 8 9 0 0.700367 0.742751 0.70928 0.566746 0.977785 0.706335 0.247916 0.157883 0.697699 0.719957 1 0.257744 0.341547 0.968761 0.694507 0.466383 0.702813 0.511786 0.928741 0.739769 0.622439 2 0.651545 0.396808 0.543239 0.7999 0.721545 0.295364 0.160946 0.206126 0.134325 0.480605 3 0.342522 0.362969 0.972918 0.110944 0.388264 0.783066 0.972897 0.48321 0.336421 0.567419 4 0.0479415 0.388937 0.906304 0.161018 0.743621 0.632974 0.32418 0.922377 0.237226 0.823946 5 0.750607 0.113784 0.845361 0.923932 0.220837 0.933054 0.488999 0.474719 0.0891675 0.229948 绘制出的图片如下： Matplotlib pcolormesh Demo 从这张图中，结合右边的 Colorbar 我们可以清晰地看到数据的分布情况。 目前的 Colorbar 是像彩虹一样的渐变形式，色值分层也是默认的连续数值。我们可以做下面的修改，自定义色值分层，自定义每个区间的颜色，让 Colorbar 显示成「一格一格」的形式。 import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import BoundaryNorm, ListedColormap # 新增 np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = plt.figure(figsize=(16, 9)) # 创建画布 ax = fig.add_subplot(111) # 修改--- # 自定义色值 LEVEL LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9] # 自定义每个区间的颜色 cmap = ListedColormap([ '#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000', ]) # type: ignore norm = BoundaryNorm(LEVEL, ncolors=cmap.N, clip=True) img = ax.pcolormesh(x, y, Z, cmap=cmap, norm=norm) # 添加填色实例 ax.set_xticks(x) # 设置 x 轴坐标 ax.set_yticks(y) # 设置 y 轴坐标 fig.colorbar(img, ax=ax, ticks=LEVEL) # 添加色带 # --- fig.savefig(\"01_test.png\", dpi=200, bbox_inches='tight') # 执行绘图并导出成图片 Matplotlib pcolormesh 自定义 colorbar 可以看到，我们设置的 LEVEL 并不是连续的数值，但每个色块显示的长度都是相同的。由此我们可以很灵活地根据业务需要去调整 Colorbar，画出我们想要的图。 ","date":"2023-05-26","objectID":"/20230527/:0:1","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"用 Plotly 绘制 Heatmap 填色图 Matplotlib 画出的图都是静态的图片，如果我们想实时看到图中每个方格里的实际值是多少，该怎么做呢？ 有很多库可以绘制交互式的图表，既可以生成 HTML 网页，也可以实时在 Jupyter Notebook 中展示，本文介绍 Plotly 的使用。 与 pcolormesh 效果对应的就是 Heatmap，上文中的第一个 Demo 实现出来是这种效果： Plotly.d3.json(\"/plotly/20230527/20230527_02.json\", function(err, fig) { Plotly.plot('\\/plotly\\/20230527\\/20230527_02.json', fig.data, fig.layout, {responsive: true}); }); 绘图代码如下： import plotly.graph_objects as go import numpy as np np.random.seed(1) np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 fig = go.Figure(data=go.Heatmap( z=Z, x=x, y=y, colorscale='jet' ) ) fig.update_layout( title='Plotly Heatmap Demo', xaxis=dict(tickvals=x, ticktext=x, title=\"X Axis\"), yaxis=dict(tickvals=y, ticktext=y, title=\"Y Axis\"), ) fig.write_json(\"02_test.html\") 这便是 Plotly 画出的交互图，把鼠标放上去可以看到每个方格的具体数值，并且可以自由放大、缩小，以及将图表保存成图片下载等等。 可以注意到这个图的 Colorbar 也是连续的彩虹状，而这个图要自定义 LEVEL 就不像 Matplotlib 那样简单了，两个库的实现思路完全不同。 这里给出实现的代码： import plotly.graph_objects as go import numpy as np import pandas as pd def trans_data(level: list, colors: list): \"\"\"转换数据 Args: level(list): 自定义层级列表 colors(list): 自定义颜色列表, 长度应比 level 小 1 Returns: (tuple): 分组转换后的数据 区间值列表 色标分层列表 \"\"\" assert len(colors) + 1 == len(level), \"colors 长度应比 level 小 1\" labels = np.arange(len(LEVEL)+1) ratio_list = np.linspace(0, 1, len(color_list)+1).tolist() colorscale_list = [[ratio_list[0], color_list[0]]] for idx, _ in enumerate(color_list[1:]): colorscale_list.append([ratio_list[idx+1], color_list[idx]]) colorscale_list.append([ratio_list[idx+1], color_list[idx+1]]) colorscale_list.append([ratio_list[-1], color_list[-1]]) Z_cut = pd.DataFrame(pd.cut( Z.flatten(), bins=[-np.infty] + LEVEL + [np.infty], labels=labels ).reshape(Z.shape)) return Z_cut, labels, colorscale_list np.random.seed(19680801) # 设置随机数种子, 保证每次生成的 Z 数据都相同 Z = np.random.rand(6, 10) # 二维网格数据, shape 为 (6x10) x = np.arange(0, 11, 1) # 长度为 11 的 x 轴坐标 y = np.arange(0, 7, 1) # 长度为 7 的 y 轴坐标 LEVEL = [0., 0.1, 0.3, 0.4, 0.8, 0.85, 0.9] color_list = ['#01A0F6', '#00ECEC', '#00D800', '#019000', '#FFFF00', '#E7C000'] Z_cut, labels, colorscale_list = trans_data(LEVEL, color_list) Z_cut_values = np.unique(Z_cut.values.flatten()) fig = go.Figure(data=go.Heatmap( z=Z_cut, x=x, y=y, colorbar=dict( tickvals=np.arange(Z_cut_values.min(), Z_cut_values.max()+1), ticktext=LEVEL ), colorscale=colorscale_list, customdata=Z, hovertemplate='x: %{x}\u003cbr\u003ey: %{y}\u003cbr\u003ez: %{customdata}\u003cextra\u003e\u003c/extra\u003e', ) ) fig.update_layout( title='Plotly Heatmap Demo', xaxis=dict(tickvals=x, ticktext=x, title=\"X Axis\"), yaxis=dict(tickvals=y, ticktext=y, title=\"Y Axis\"), ) fig.write_html(\"03_test.html\") 图表效果是这样： Plotly.d3.json(\"/plotly/20230527/20230527_03.json\", function(err, fig) { Plotly.plot('\\/plotly\\/20230527\\/20230527_03.json', fig.data, fig.layout, {responsive: true}); }); ","date":"2023-05-26","objectID":"/20230527/:0:2","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"},{"categories":null,"content":"参考资料 Including plotly figures in Hugo posts ","date":"2023-05-26","objectID":"/20230527/:0:3","tags":null,"title":"用 Plotly Python 绘制 Heatmap，自定义不等距 Colorbar","uri":"/20230527/"}]